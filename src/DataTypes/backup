//
// Created by WuBin on 24-10-29.
//
#ifndef AUDIODATA_H
#define AUDIODATA_H
#include "QtNodes/NodeData"
#include <QMetaType>
#include <QQueue>
#include <QMutex>
#include <QAtomicInt>
#include <memory>
#include <QDateTime>
#include <QMap>
#include <QObject>  // 添加QObject头文件

using QtNodes::NodeData;
using QtNodes::NodeDataType;

// 定义音频帧数据结构
struct AudioFrame {
    QByteArray data;        // 音频数据
    int sampleRate;         // 采样率
    int channels;           // 通道数
    int bitsPerSample;     // 每个采样的位数
    qint64 timestamp;       // 时间戳

    AudioFrame() : sampleRate(0), channels(0), bitsPerSample(0), timestamp(0) {}
};
// 消费者信息结构体
struct ConsumerInfo {
    int consumerId;                 // 消费者ID
    int readIndex;                  // 当前读取位置

    qint64 readTimestamp;      // 最后读取时间戳

    ConsumerInfo()
        : consumerId(-1)
        , readIndex(0)

        , readTimestamp(0)
    {}
};

/**
 * @brief 基于时间戳的有限音频队列
 * AudioDecoder始终写入队首，AudioDeviceOut根据时间戳提取最接近的帧
 * 根据队列长度动态调整播放速度，避免缓存溢出
 */
class AudioTimestampQueue {
public:
    /**
     * @brief 构造函数
     * @param maxSize 队列最大长度（帧数）
     */
    explicit AudioTimestampQueue(int maxSize = 8)
        : maxSize_(maxSize), isActive_(true) {
    }

    /**
     * @brief 写入音频帧到队首（AudioDecoder调用）
     * @param frame 音频帧数据
     * @return 写入成功返回true，队列满时自动移除最旧帧
     */
    bool pushFrame(const AudioFrame& frame) {
        QMutexLocker locker(&mutex_);

        if (!isActive_) return false;

        // 如果队列满了，移除最旧的帧（队尾）
        if (frames_.size() >= maxSize_) {
            frames_.removeLast();
        }

        // 插入到队首，保持时间戳有序
        frames_.prepend(frame);

        return true;
    }

    /**
     * @brief 根据目标时间戳查找最接近的音频帧（AudioDeviceOut调用）
     * @param consumerId 消费者ID
     * @param targetTimestamp 目标时间戳（毫秒）
     * @param tolerance 时间容差（毫秒），默认50ms
     * @param frame 输出的音频帧
     * @return 找到合适帧返回true，否则返回false
     */
    bool getFrameByTimestamp(int consumerId, qint64 targetTimestamp, qint64 tolerance, AudioFrame& frame) {
        QMutexLocker locker(&mutex_);

        if (frames_.isEmpty()) return false;

        // 检查消费者是否已注册
        if (!consumerReadIndices_.contains(consumerId)) {
            return false;
        }

        int bestIndex = -1;
        qint64 minTimeDiff = LLONG_MAX;

        for (int i = 0; i < frames_.size(); ++i) {
            qint64 timeDiff = std::abs(frames_[i].timestamp - targetTimestamp);
            if (timeDiff <= tolerance && timeDiff < minTimeDiff) {
                minTimeDiff = timeDiff;
                bestIndex = i;
            }
        }

        if (bestIndex >= 0) {
            frame = frames_[bestIndex];
            // 更新该消费者的读取索引到下一个位置
            consumerReadIndices_[consumerId] = bestIndex;
            return true;
        }

        return false;
    }

    /**
     * @brief 获取当前队列长度
     * @return 队列中的帧数
     */
    int getCurrentSize() const {
        QMutexLocker locker(&mutex_);
        return frames_.size();
    }

    /**
     * @brief 获取队列使用率（0.0-1.0）
     * @return 使用率，基于消费者读取索引的最大值与队列最大容量的比值
     */
    double getUsedRatio() const {
        QMutexLocker locker(&mutex_);

        if (consumerReadIndices_.isEmpty()) {
            return -1; // 没有消费者时使用率为0
        }

        // 找到所有消费者中的最大读取索引
        int maxReadIndex = 0;
        for (auto it = consumerReadIndices_.begin(); it != consumerReadIndices_.end(); ++it) {
            maxReadIndex = std::max(maxReadIndex, it.value());
        }

        // 计算使用率：最大读取索引与队列最大容量的比值
        return static_cast<double>(maxReadIndex) / maxSize_;
    }

    /**
     * @brief 清空队列
     */
    void clear() {
        QMutexLocker locker(&mutex_);
        frames_.clear();
    }

    /**
     * @brief 设置队列激活状态
     */
    void setActive(bool active) {
        QMutexLocker locker(&mutex_);
        isActive_ = active;
    }

    /**
     * @brief 获取队列激活状态
     */
    bool isActive() const {
        QMutexLocker locker(&mutex_);
        return isActive_;
    }
    /**
       * @brief 注册消费者并分配读取索引（自动分配ID）
       * @return 分配的消费者ID，-1表示失败
       */
    int registerNewConsumer() {
        static QAtomicInt nextId(1);
        int consumerId = nextId.fetchAndAddAcquire(1);

        if (registerConsumer(consumerId)) {
            return consumerId;
        }
        return -1;
    }

    /**
     * @brief 注册指定ID的消费者
     * @param consumerId 消费者ID
     * @return 是否注册成功
     */
    bool registerConsumer(int consumerId) {
        if (consumerReadIndices_.contains(consumerId)) {
            return false; // 消费者已存在
        }
        consumerReadIndices_[consumerId] = 0;

        return true;
    }

    /**
     * @brief 注销消费者
     * @param consumerId 消费者ID
     * @return 是否注销成功
     */
    bool unregisterConsumer(int consumerId) {

        if (!consumerReadIndices_.contains(consumerId)) {
            return false; // 消费者不存在
        }
        consumerReadIndices_.remove(consumerId);
        return true;
    }
private:
    QList<AudioFrame> frames_;          // 音频帧队列（按时间戳排序）
    int maxSize_;                       // 队列最大长度
    bool isActive_;                     // 队列激活状态
    mutable QMutex mutex_;              // 线程安全互斥锁
    QMap<int, int> consumerReadIndices_;      // 消费者读取索引表 <消费者ID, 读取索引>
};